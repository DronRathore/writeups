<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">@import url('https://themes.googleusercontent.com/fonts/css?kit=KAcgnVa0IBppVRWtHAiHYqK38JZohY0yn7T0XHfI1tWstm_gK6ESXBEr-ck3zGUx');ol{margin:0;padding:0}table td,table th{padding:0}.c0{border-right-style:solid;padding:5pt 5pt 5pt 5pt;border-bottom-color:#000000;border-top-width:1pt;border-right-width:1pt;border-left-color:#000000;vertical-align:top;border-right-color:#000000;border-left-width:1pt;border-top-style:solid;border-left-style:solid;border-bottom-width:1pt;width:451.4pt;border-top-color:#000000;border-bottom-style:solid}.c18{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c21{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Montserrat";font-style:normal}.c17{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Montserrat";font-style:normal}.c19{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c14{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:11pt;font-family:"Montserrat";font-style:normal}.c23{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:8pt;font-family:"Consolas";font-style:normal}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Montserrat";font-style:normal}.c11{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:10pt;font-family:"Consolas";font-style:normal}.c15{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:11pt}.c3{color:#000000;font-weight:700;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Montserrat";font-style:normal}.c10{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:center}.c4{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c20{padding-top:0pt;padding-bottom:0pt;line-height:1.0;text-align:left}.c2{vertical-align:sub;font-size:10pt;font-family:"Montserrat";font-weight:700}.c8{border-spacing:0;border-collapse:collapse;margin-right:auto}.c22{font-size:9pt;font-family:"Montserrat";font-style:italic;font-weight:400}.c16{background-color:#ffffff;max-width:451.4pt;padding:72pt 72pt 72pt 72pt}.c7{font-size:10pt;font-family:"Montserrat";font-weight:400}.c9{font-size:10pt;font-family:"Montserrat";font-weight:700}.c13{vertical-align:sub}.c12{margin-left:-42.5pt}.c5{height:0pt}.title{padding-top:0pt;color:#000000;font-size:26pt;padding-bottom:3pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:11pt;font-family:"Arial"}p{margin:0;color:#000000;font-size:11pt;font-family:"Arial"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Arial";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c16"><p class="c15 title" id="h.hq6v5afrfokn"><span class="c17">Reasonable consensus in a dynamic system using chromatic number</span></p><p class="c10"><span class="c23">Dron Rathore&lt;dron.rathore@gmail.com&gt;</span></p><p class="c1"><span class="c21"></span></p><h1 class="c19" id="h.435fk3xqlg8"><span class="c3">Abstract</span></h1><p class="c4"><span class="c6">Negotiating and agreeing on certain states within a system has been a classic research area, from paxos, raft to the recent flexible paxos theory all have tried to solve the issue of consensus using various methodologies. In this document I would like to propose a more distinct approach for solving consensus problems in a distributed system.</span></p><p class="c1"><span class="c21"></span></p><h1 class="c19" id="h.jkquxsppnd98"><span class="c3">System as graph</span></h1><p class="c4"><span class="c6">The first and foremost concept in this approach is to visualise your distributed system as an open graph with the leader being at the center of the node and followers being the vertices of the graph.</span><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 215.50px; height: 186.77px;"><img alt="" src="images/image15.png" style="width: 215.50px; height: 186.77px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">The center or the leader position can be swapped by any node that is currently sitting on a vertice, any number of vertices can be added and/or replaced from the system at any point of time as long as the total number of nodes in the system is </span><img src="images/image1.png"></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">The followers can all be in a various different commit ID states, where a commit ID is a universal consistent sequential ID associated with a log message in the system.</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">The current leader is the one responsible for incrementing the commit ID and moving the state machine forward.</span></p><p class="c1"><span class="c6"></span></p><h1 class="c19" id="h.7fk1rdft4fls"><span class="c3">Initial state</span></h1><p class="c4"><span class="c7">T</span><span class="c6">o kick start the system we would need to assign a leader first, the initial state of the system can also be represented as a graph depicted below.</span></p><p class="c4"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 205.50px; height: 175.06px;"><img alt="" src="images/image14.png" style="width: 205.50px; height: 175.06px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c4"><span class="c6">In the initial state all nodes are staking claims to become a leader, the initial state of the individual node is currently a self generated random integer/UUID which is being sent around by individual nodes to all the other nodes. The node which ended up generating the largest value should be elected as a leader, we call this state circle of chaos as the system could easily drift into eternal ping-pong if we are unable to elect a leader because of poor random number generation or any other causes.</span></p><p class="c4"><span class="c6">The election in this initial state is done with total consensus i.e. all nodes must acknowledge the node which generated the largest value as their leader. Once the total consensus has been reached, the states of nodes will be as following</span></p><p class="c1"><span class="c6"></span></p><p class="c10"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 530.50px; height: 248.71px;"><img alt="" src="images/image13.png" style="width: 530.50px; height: 248.71px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><h1 class="c19" id="h.iwp3o02f2zp6"><span class="c3">ChangeLog consensus</span></h1><p class="c4"><span class="c6">In a distributed system applying change log to self, distributing it to all the followers, waiting for majority consensus is a standard procedure of operation. However the key component for a state machine system is to define &ldquo;majority consensus&rdquo; or &ldquo;reasonable majority consensus&rdquo;, the term &ldquo;majority/reasonable&rdquo; can be flexed around to tune the system for various types of workload.</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">In our case we will search for the answer in graph coloring methodology, we will be tweaking the graph coloring methodology to fit our consensus problem.</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">We begin by introducing 2 key lemmas:</span></p><p class="c1"><span class="c6"></span></p><a id="t.a083f0a7f1cfe8193b7016179ecf6d56ce82d9bb"></a><a id="t.0"></a><table class="c8"><tbody><tr class="c5"><td class="c0" colspan="1" rowspan="1"><p class="c4"><span class="c11">Lemma 1: Given a distributed set of nodes, we define that a Node can uniquely be identified by the last commit ID it has applied to its state machine.</span></p></td></tr></tbody></table><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">So if 2 nodes have last applied commit ID as </span><img src="images/image2.png"><span class="c6">&nbsp;then both are identical nodes purely for the evaluation of consensus.</span></p><p class="c1"><span class="c6"></span></p><a id="t.fb5a25a09de11ea460d7c473643fa759e154e797"></a><a id="t.1"></a><table class="c8"><tbody><tr class="c5"><td class="c0" colspan="1" rowspan="1"><p class="c4"><span class="c11">Lemma 2: A distributed state machine in which all nodes have applied all the changes is said to be an ideal state machine, as no node is distinguishable from another in terms of the applied changes to their respective state machine.</span></p></td></tr></tbody></table><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">An ideal state of the system can be achieved when no new commits are arriving and all the nodes in the system has applied the </span><img src="images/image3.png"></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">Now we would like to introduce the concept of coloring the nodes as our basis to solve consensus problem, using </span><span class="c22">Lemma 1</span><span class="c6">, we introduce a key feature to our system:</span></p><p class="c1"><span class="c6"></span></p><a id="t.4900d5a5285332ee43fdd0dd121847ead2c7f9e3"></a><a id="t.2"></a><table class="c8"><tbody><tr class="c5"><td class="c0" colspan="1" rowspan="1"><p class="c4"><span class="c11">Lemma 3: Nodes with same commit ID corresponds to the same color</span></p></td></tr></tbody></table><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">Let&rsquo;s take an example of a system of 3 nodes where the leader </span><img src="images/image4.png"><span class="c7">&nbsp;is at commit ID </span><img src="images/image2.png"><span class="c7">, node </span><img src="images/image5.png"><span class="c7">is at commit ID </span><img src="images/image6.png"><span class="c7">and node </span><img src="images/image7.png"><span class="c7">is at commit ID </span><img src="images/image8.png"><span class="c6">, using the above lemma if we move the state machine through time we will end up with the following colored states.</span></p><p class="c1"><span class="c6"></span></p><p class="c4 c12"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 736.67px; height: 422.38px;"><img alt="" src="images/image16.png" style="width: 736.67px; height: 422.38px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c1 c12"><span class="c6"></span></p><p class="c4"><span class="c6">The last state in the above diagram is what is referred to in lemma 2 as an ideal state machine, in this state any node can be elected as a leader which is the case in the initial state of the system.</span></p><h2 class="c18" id="h.8fnz83mwfoxu"><span class="c14">Reasonable Majority Consensus </span></h2><p class="c4"><span class="c7">To derive a reasonable majority consensus we take a graph of </span><img src="images/image9.png"><span class="c7">nodes with </span><img src="images/image4.png"><span class="c6">being the leader, we replace all the nodes which have the same commit ID with a single node and then assign a unique color to each node, the number of colors used in this stage is the minimum number of acknowledgements required in order to accept a change in the system.</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">For a set of </span><img src="images/image2.png"><span class="c7">nodes from </span><span class="c9">N</span><span class="c2">1</span><span class="c7">&nbsp;to </span><span class="c9">N</span><span class="c2">x</span><span class="c7">&nbsp;each being in state </span><span class="c9">s</span><span class="c2">1</span><span class="c7 c13">,</span><span class="c2">&nbsp;</span><span class="c9">s</span><span class="c2">2,</span><span class="c7 c13">&nbsp;</span><span class="c9">s</span><span class="c2">3 </span><span class="c7 c13">&nbsp;&hellip; </span><span class="c9">s</span><span class="c2">x</span><span class="c7">&nbsp;we define the </span><img src="images/image10.png"><span class="c6">required to reach consensus as:</span></p><p class="c1"><span class="c6"></span></p><a id="t.4f7e754323db9370c01539c520c187bf7f9ee6e1"></a><a id="t.3"></a><table class="c8"><tbody><tr class="c5"><td class="c0" colspan="1" rowspan="1"><p class="c10"><img src="images/image11.png"></p></td></tr></tbody></table><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">where; state is the commit ID of that particular node</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">The above gives us the lower bound for any system with </span><img src="images/image1.png"><span class="c7">&nbsp;as </span><img src="images/image12.png"><span class="c6">, the assumption here always is that the leader has applied the change and is now waiting for acknowledgement from it&rsquo;s followers.</span></p><p class="c1"><span class="c6"></span></p><p class="c1"><span class="c6"></span></p><a id="t.f4735b17019bd2673d487c38c5feeb5ccb493e14"></a><a id="t.4"></a><table class="c8"><tbody><tr class="c5"><td class="c0" colspan="1" rowspan="1"><p class="c20"><span class="c11">The minimum number of acknowledgements required to reach a reasonable consensus in any N node system is 2.</span></p></td></tr></tbody></table><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">In a worse case scenario we will have all the nodes lagging behind from the leader and that would force us to reach total consensus before accepting the change. </span></p><p class="c1"><span class="c6"></span></p><a id="t.53620b0b3af6aaaed92f87ce0c5791a2378bfdb6"></a><a id="t.5"></a><table class="c8"><tbody><tr class="c5"><td class="c0" colspan="1" rowspan="1"><p class="c20"><span class="c11">The maximum number of acknowledgements required to reach a reasonable consensus in any N node system is N.</span></p></td></tr></tbody></table><p class="c1"><span class="c6"></span></p><h1 class="c19" id="h.1yfftvo0utwj"><span class="c3">Conclusion</span></h1><p class="c4"><span class="c6">The reasonable consensus approach provides us the upper as well as the lower limits for required acknowledgements in an N node system.</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">Taking the approach away from the enforced fixed requirement of &frac12; or &#8531; majority, the reasonable consensus approach ensures that we only wait for acks from the optimal minimum required nodes. If a system is in a smooth operation where commits are applied as soon as they arrive at the nodes; we don&rsquo;t have to wait for a majority consensus as the degree of confidence in the system is high. This increases the overall efficiency &amp; speed of operation for the system.</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">However let&rsquo;s assume a case where in an </span><img src="images/image9.png"><span class="c7">node system, </span><img src="images/image2.png"><span class="c6">&nbsp;number of nodes are slow to catch up, in that case our rate of confidence in the system&rsquo;s durability &amp; consistency decreases. The reason being in case of a leader and/or multi node failure we are at risk of losing data, this will trigger the system to automatically increase the required number of acknowledgements, this trait of the system can be termed as self reassuring, though this will come at cost of speed.</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c6">As the minimum number of acknowledgements is a dynamic metric, the system is capable of adjusting the required consensus amount on the basis of the number of nodes in the system at a given point of time.</span></p><h1 class="c19" id="h.8h763hsvamka"><span class="c3">Further work</span></h1><p class="c4"><span class="c6">The approach can be further refined in order to strengthen the degree of confidence by introducing a 2 phase feature of soft &amp; hard acknowledgement, where soft ack is when the leader has sent the data over wire and has received the network acknowledgement from a follower. We could increase the requirement for soft commit and further lower our hard acknowledgement requirements.</span></p><p class="c1"><span class="c6"></span></p><p class="c4"><span class="c7">Another addition in the approach will be to have a monitoring &amp; estimation of reachability speed from leader to follower which can then be shared among all the nodes with a heartbeat as it can help the leader reelection process. I will do a write up on both the features in future.</span></p></body></html>